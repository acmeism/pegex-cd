// Generated by CoffeeScript 1.3.3
(function() {
  var Input, Parser, Receiver,
    __slice = [].slice;

  Input = require('../Pegex/Input');

  Receiver = require('../Pegex/Receiver');

  Parser = (function() {

    function Parser(grammar, receiver) {
      this.grammar = grammar;
      this.receiver = receiver;
      this.receiver || (this.receiver = new require('./Pegex/Receiver'));
      this.throw_on_error = true;
      this.wrap = this.receiver.wrap;
      this.input = '';
      this.buffer = '';
      this.error = null;
      this.position = 0;
      this.debug = false;
    }

    Parser.prototype.parse = function(input, start_rule) {
      var grammar, match, receiver, _ref, _ref1, _ref2;
      this.input = input;
      this.buffer = this.input.read();
      grammar = (function() {
        if ((_ref = this.grammar) != null) {
          return _ref;
        } else {
          throw "No 'grammar'. Can't parse";
        }
      }).call(this);
      if (typeof grammar === 'string') {
        require('../' + grammar);
        this.grammar = new grammar;
      }
      if (start_rule == null) {
        start_rule = (_ref1 = this.grammar.tree['+toprule']) != null ? _ref1 : (function() {
          if (this.grammar.tree['TOP']) {
            return 'TOP';
          } else {
            throw "No starting rule for Pegex.Parser.parse";
          }
        })();
      }
      receiver = (function() {
        if ((_ref2 = this.receiver) != null) {
          return _ref2;
        } else {
          throw "No 'receiver'. Can't parse";
        }
      }).call(this);
      if (typeof receiver === 'string') {
        require('../' + receiver);
        this.receiver = new receiver;
      }
      this.receiver.parser = this;
      match = this.match(start_rule);
      if (!match) {
        return;
      }
      this.input.close();
      return this.receiver.data || match;
    };

    Parser.prototype.match = function(rule) {
      var match, _ref;
      if (this.receiver.prototype.initialize) {
        this.receiver.initialize(rule);
      }
      match = this.match_next({
        '.ref': rule
      });
      if (!match || this.position < this.buffer.length) {
        this.throw_error("Parse document failed for some reason");
        return;
      }
      match = match[0];
      if (this.receiver.prototype.finalize) {
        match = this.receiver.finalize(match(rule));
      }
      if (!match) {
        match = {
          rule: []
        };
      }
      if (rule === 'TOP') {
        match = (_ref = match['TOP']) != null ? _ref : match;
      }
      return match;
    };

    Parser.prototype.get_min_max = function(next) {
      var max, min, _ref;
      if (next['.sep']) {
        return this.match_next_with_sep(next);
      }
      _ref = [next['+min'], next['+max']], min = _ref[0], max = _ref[1];
      if (min != null) {
        if (max != null) {
          return [min, max];
        } else {
          return [min, 0];
        }
      } else {
        if (max != null) {
          return [0, max];
        } else {
          return [1, 1];
        }
      }
    };

    Parser.prototype.match_next = function(next) {
      var assertion, count, key, keys, kind, match, max, method, min, position, result, return_, rule, _ref, _ref1, _ref2, _ref3;
      if (next['.sep']) {
        return this.match_next_with_sep(next);
      }
      _ref = this.get_min_max(next), min = _ref[0], max = _ref[1];
      assertion = (_ref1 = next['+asr']) != null ? _ref1 : 0;
      keys = ['ref', 'rgx', 'all', 'err', 'code'];
      _ref2 = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          key = keys[_i];
          if (next["." + key] != null) {
            _results.push([next["." + key], key]);
          }
        }
        return _results;
      })(), rule = _ref2[0], kind = _ref2[1];
      _ref3 = [[], this.position, 0, "match_" + kind], match = _ref3[0], position = _ref3[1], count = _ref3[2], method = _ref3[3];
      while (return_ = method.call(this(rule(next)))) {
        if (!assertion) {
          position = this.position;
        }
        count++;
        match.push.apply(match, return_);
        if (max === 1) {
          break;
        }
      }
      if (max !== 1) {
        match = [match];
        this.set_position(position);
      }
      result = count >= min && (!max || count <= max);
      result ^= assertion === -1;
      if (!result || assertion) {
        this.set_position(position);
      }
      if (next['-skip']) {
        match = [];
      }
      return result && match || 0;
    };

    Parser.prototype.match_next_with_sep = function(next) {
      var count, key, kind, match, max, method, min, position, result, return2, return_, rule, scount, separator, smax, smin, _ref, _ref1, _ref2;
      _ref = this.get_min_max(next), min = _ref[0], max = _ref[1];
      _ref1 = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          key = keys[_i];
          if (next["." + key] != null) {
            _results.push([next["." + key], key]);
          }
        }
        return _results;
      })(), rule = _ref1[0], kind = _ref1[1];
      separator = next['.sep'];
      _ref2 = [[], this.position, 0, "match_" + kind, 0, this.get_min_max(separator)], match = _ref2[0], position = _ref2[1], count = _ref2[2], method = _ref2[3], scount = _ref2[4], smin = _ref2[5], smax = _ref2[6];
      while (return_ = method.call(this(rule(next)))) {
        position = this.position;
        count++;
        match.push.apply(match, return_);
        if (!(return_ = this.match_next(separator))) {
          break;
        }
        return2 = __slice.call(return_);
        if (return2.length) {
          return2 = ['XXX'](ix(smax !== 1));
          match.push.apply(match, return2);
        }
        scount++;
      }
      if (max !== 1) {
        match = [match];
      }
      result = count >= min && (!max || count <= max);
      if (count === scount && !separator['+eok']) {
        this.set_position(position);
      }
      if (next['-skip']) {
        match = [];
      }
      return result && match || 0;
    };

    Parser.prototype.match_ref = function(ref, parent) {
      var callback, match, rule, sub, trace;
      rule = this.grammar.tree[ref];
      rule || (rule = (function() {
        if (this.prototype["match_rule_" + ref]) {
          return {
            '.code': ref
          };
        } else {
          throw "\n\n*** No grammar support for '" + ref + "'\n\n";
        }
      }).call(this));
      trace = !rule['+asr'] && this.debug;
      if (trace) {
        this.trace("try_" + ref);
      }
      match = typeof rule === 'function' ? rule.call(this) : this.match_next(rule);
      if (match) {
        if (trace) {
          this.trace("got_" + ref);
        }
        if (!rule['+asr'] && !parent['-skip']) {
          callback = "got_" + ref;
          sub = this.receiver.prototype[callback];
          if (sub != null) {
            match = [sub.call(this.receiver, match[0])];
          } else if (this.wrap && !parent['-pass'] || parent['-wrap']) {
            match = match.length ? [
              {
                ref: match[0]
              }
            ] : [];
          }
        }
      } else {
        this.trace("not_" + ref);
        match = 0;
      }
      return match;
    };

    Parser.prototype.xxx_terminator_hack = 0;

    Parser.prototype.xxx_terminator_max = 1000;

    Parser.prototype.match_rgx = function(regexp, parent) {
      var finish, m, match, num, re, start, _i, _ref;
      start = this.position;
      if (start >= this.buffer.length && this.xxx_terminator_hack++ > this.xxx_terminator_max) {
        throw "Your grammar seems to not terminate at end or stream";
      }
      re = new RegExp(regexp, 'g');
      re.lastIndex = start;
      m = re.exec(this.buffer);
      if (!m) {
        return 0;
      }
      finish = re.lastIndex;
      for (num = _i = 1, _ref = m.length; 1 <= _ref ? _i < _ref : _i > _ref; num = 1 <= _ref ? ++_i : --_i) {
        match = m[num];
      }
      if (m.length > 1) {
        match = [match];
      }
      this.set_position(finish);
      return match;
    };

    Parser.prototype.match_all = function(list, parent) {
      var elem, len, match, pos, set, _i, _len;
      pos = this.position;
      set = [];
      len = 0;
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        elem = list[_i];
        if (match = this.match_next(elem)) {
          if (elem['+asr'] || elem['-skip']) {
            continue;
          }
          set.push(match);
          len++;
        } else {
          this.set_position(pos);
          return 0;
        }
      }
      if (len > 1) {
        set = [set];
      }
      return set;
    };

    Parser.prototype.match_any = function(list, parent) {
      var elem, match, _i, _len;
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        elem = list[_i];
        if (match = this.match_next(elem)) {
          return match;
        }
      }
      return 0;
    };

    Parser.prototype.match_err = function(error) {
      return this.throw_error(error);
    };

    Parser.prototype.match_code = function(code) {
      var method;
      method = "match_rule_" + code;
      return method.call(this);
    };

    Parser.prototype.set_position = function(position) {
      this.position = position;
      if (position > this.farthest) {
        return this.farthest = position;
      }
    };

    Parser.prototype.trace = function(action) {
      var indent, indentation, snippet, x, _i, _ref;
      indent = action.match(/^try_/);
      this.indent || (this.indent = 0);
      if (!indent) {
        this.indent--;
      }
      indentation = '';
      for (x = _i = 1, _ref = this.indent; 1 <= _ref ? _i <= _ref : _i >= _ref; x = 1 <= _ref ? ++_i : --_i) {
        indentation += ' ';
      }
      if (indent) {
        this.indent++;
      }
      snippet = this.buffer.substr(this.position);
      if (snippet.length > 30) {
        snippet = snippet.substr(0, 30);
      }
      snippet = snippet.replace(/\n/, '\\n');
      return console.warn("" + indentation + ">" + snippet + "<\n");
    };

    Parser.prototype.throw_error = function(msg) {
      this.format_error(msg);
      if (!this.throw_on_error) {
        return 0;
      }
      throw this.error;
    };

    Parser.prototype.format_error = function(msg) {
      var column, context, line, position, _base;
      position = this.farthest;
      line = this.buffer.substr(0, typeof (_base = position(match(/\n/g))) === "function" ? _base(length + 1) : void 0);
      column = position - this.buffer.lastIndexOf("\n", position);
      context = this.buffer.substr(position, 50);
      context = context.replace(/\n/, '\\n');
      return this.error = "Error parsing Pegex document:\n  msg: " + msg + "\n  line: " + line + "\n  column: " + column + "\n  context: " + context + "\n  position: " + position;
    };

    return Parser;

  })();

}).call(this);
