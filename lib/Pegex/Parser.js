// Generated by CoffeeScript 1.3.3
(function() {
  var Input, Parser, Receiver,
    __slice = [].slice;

  Input = require('../Pegex/Input').Input;

  Receiver = require('../Pegex/Receiver').Receiver;

  exports.Parser = Parser = (function() {

    function Parser(grammar, receiver) {
      this.grammar = grammar;
      this.receiver = receiver;
      this.receiver || (this.receiver = new require('./Pegex/Receiver'));
      this.throw_on_error = true;
      this.wrap = this.receiver.wrap;
      this.input = '';
      this.buffer = '';
      this.error = null;
      this.position = 0;
      this.farthest = 0;
      this.debug = true;
      this.debug = false;
    }

    Parser.prototype.parse = function(input, start_rule) {
      var Grammar, grammar, match, receiver, _base, _ref, _ref1, _ref2, _ref3, _ref4,
        _this = this;
      this.input = input;
      if (typeof this.input === 'string') {
        this.input = new Input({
          string: this.input
        });
      }
      this.input.open();
      this.buffer = this.input.read();
      grammar = (function() {
        if ((_ref = this.grammar) != null) {
          return _ref;
        } else {
          throw "No 'grammar'. Can't parse";
        }
      }).call(this);
      if (typeof grammar === 'string') {
        Grammar = require('../' + grammar);
        this.grammar = new Grammar;
      } else {
        if ((_ref1 = (_base = this.grammar).tree) == null) {
          _base.tree = this.grammar.make_tree();
        }
      }
      if (start_rule == null) {
        start_rule = (_ref2 = (_ref3 = this.grammar.tree) != null ? _ref3['+toprule'] : void 0) != null ? _ref2 : (function() {
          if (_this.grammar.tree['TOP']) {
            return 'TOP';
          } else {
            throw "No starting rule for Pegex.Parser.parse";
          }
        })();
      }
      receiver = (function() {
        if ((_ref4 = this.receiver) != null) {
          return _ref4;
        } else {
          throw "No 'receiver'. Can't parse";
        }
      }).call(this);
      if (typeof receiver === 'string') {
        require('../' + receiver);
        this.receiver = new receiver;
      }
      this.receiver.parser = this;
      match = this.match(start_rule);
      if (!match) {
        return;
      }
      this.input.close();
      return this.receiver.data || match;
    };

    Parser.prototype.match = function(rule) {
      var match, _ref;
      if (this.receiver.constructor.prototype.initialize) {
        this.receiver.initialize(rule);
      }
      match = this.match_next({
        '.ref': rule
      });
      if (!match || this.position < this.buffer.length) {
        this.throw_error("Parse document failed for some reason");
        return;
      }
      match = match[0];
      if (this.receiver.constructor.prototype.finalize) {
        match = this.receiver.finalize(match(rule));
      }
      if (!match) {
        match = {
          rule: []
        };
      }
      if (rule === 'TOP') {
        match = (_ref = match['TOP']) != null ? _ref : match;
      }
      return match;
    };

    Parser.prototype.get_min_max = function(next) {
      var max, min, _ref;
      _ref = [next['+min'], next['+max']], min = _ref[0], max = _ref[1];
      if (min != null) {
        if (max != null) {
          return [min, max];
        } else {
          return [min, 0];
        }
      } else {
        if (max != null) {
          return [0, max];
        } else {
          return [1, 1];
        }
      }
    };

    Parser.prototype.match_next = function(next) {
      var assertion, count, key, keys, kind, match, max, method, min, position, result, return_, rule, _i, _len, _ref, _ref1, _ref2;
      if (next['.sep']) {
        return this.match_next_with_sep(next);
      }
      _ref = this.get_min_max(next), min = _ref[0], max = _ref[1];
      assertion = (_ref1 = next['+asr']) != null ? _ref1 : 0;
      keys = ['ref', 'rgx', 'all', 'any', 'err', 'code'];
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        key = keys[_i];
        if (!(next["." + key] != null)) {
          continue;
        }
        kind = key;
        rule = next["." + key];
      }
      _ref2 = [[], this.position, 0, "match_" + kind], match = _ref2[0], position = _ref2[1], count = _ref2[2], method = _ref2[3];
      while (return_ = this[method].call(this, rule, next)) {
        if (!assertion) {
          position = this.position;
        }
        count++;
        match.push.apply(match, return_);
        if (max === 1) {
          break;
        }
      }
      if (max !== 1) {
        match = [match];
        this.set_position(position);
      }
      result = count >= min && (!max || count <= max);
      result ^= assertion === -1;
      if (!result || assertion) {
        this.set_position(position);
      }
      if (next['-skip']) {
        match = [];
      }
      return result && match || 0;
    };

    Parser.prototype.match_next_with_sep = function(next) {
      var count, key, keys, kind, match, max, method, min, position, result, return2, return_, rule, scount, separator, smax, smin, _i, _len, _ref, _ref1, _ref2;
      _ref = this.get_min_max(next), min = _ref[0], max = _ref[1];
      keys = ['ref', 'rgx', 'all', 'any', 'err', 'code'];
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        key = keys[_i];
        if (!(next["." + key] != null)) {
          continue;
        }
        kind = key;
        rule = next["." + key];
      }
      separator = next['.sep'];
      _ref1 = [[], this.position, 0, "match_" + kind, 0, this.get_min_max(separator)], match = _ref1[0], position = _ref1[1], count = _ref1[2], method = _ref1[3], scount = _ref1[4], (_ref2 = _ref1[5], smin = _ref2[0], smax = _ref2[1]);
      while (return_ = this[method].call(this, rule, next)) {
        position = this.position;
        count++;
        match.push.apply(match, return_);
        if (!(return_ = this.match_next(separator))) {
          break;
        }
        return2 = __slice.call(return_);
        if (return2.length) {
          return2 = ['XXX'](ix(smax !== 1));
          match.push.apply(match, return2);
        }
        scount++;
      }
      if (max !== 1) {
        match = [match];
      }
      result = count >= min && (!max || count <= max);
      if (count === scount && !separator['+eok']) {
        this.set_position(position);
      }
      if (next['-skip']) {
        match = [];
      }
      return result && match || 0;
    };

    Parser.prototype.match_ref = function(ref, parent) {
      var callback, match, rule, sub, trace;
      rule = this.grammar.tree[ref];
      rule || (rule = (function() {
        if (this.prototype["match_rule_" + ref]) {
          return {
            '.code': ref
          };
        } else {
          throw "\n\n*** No grammar support for '" + ref + "'\n\n";
        }
      }).call(this));
      trace = !rule['+asr'] && this.debug;
      if (trace) {
        this.trace("try_" + ref);
      }
      match = typeof rule === 'function' ? rule.call(this) : this.match_next(rule);
      if (match) {
        if (trace) {
          this.trace("got_" + ref);
        }
        if (!rule['+asr'] && !parent['-skip']) {
          callback = "got_" + ref;
          sub = this.receiver.constructor.prototype[callback];
          if (sub != null) {
            match = [sub.call(this.receiver, match[0])];
          } else if (this.wrap && !parent['-pass'] || parent['-wrap']) {
            match = match.length ? [
              {
                ref: match[0]
              }
            ] : [];
          }
        }
      } else {
        if (trace) {
          this.trace("not_" + ref);
        }
        match = 0;
      }
      if (match && this.debug) {
        say(match);
      }
      return match;
    };

    Parser.prototype.xxx_terminator_hack = 0;

    Parser.prototype.xxx_terminator_max = 1000;

    Parser.prototype.match_rgx = function(regexp, parent) {
      var finish, m, match, num, re, start, _i, _ref;
      start = this.position;
      if (start >= this.buffer.length && this.xxx_terminator_hack++ > this.xxx_terminator_max) {
        throw "Your grammar seems to not terminate at end or stream";
      }
      re = new RegExp(regexp, 'g');
      re.lastIndex = start;
      m = re.exec(this.buffer);
      if (!(m != null) || m.index !== start) {
        return 0;
      }
      finish = re.lastIndex;
      match = [];
      for (num = _i = 1, _ref = m.length; 1 <= _ref ? _i < _ref : _i > _ref; num = 1 <= _ref ? ++_i : --_i) {
        match.push(m[num]);
      }
      if (m.length > 2) {
        match = [match];
      }
      this.set_position(finish);
      return match;
    };

    Parser.prototype.match_all = function(list, parent) {
      var elem, len, match, pos, set, _i, _len;
      pos = this.position;
      set = [];
      len = 0;
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        elem = list[_i];
        if (match = this.match_next(elem)) {
          if (elem['+asr'] || elem['-skip']) {
            continue;
          }
          set.push.apply(set, match);
          len++;
        } else {
          this.set_position(pos);
          return 0;
        }
      }
      if (len > 1) {
        set = [set];
      }
      return set;
    };

    Parser.prototype.match_any = function(list, parent) {
      var elem, match, _i, _len;
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        elem = list[_i];
        if (match = this.match_next(elem)) {
          return match;
        }
      }
      return 0;
    };

    Parser.prototype.match_err = function(error) {
      return this.throw_error(error);
    };

    Parser.prototype.match_code = function(code) {
      var method;
      method = "match_rule_" + code;
      return method.call(this);
    };

    Parser.prototype.set_position = function(position) {
      this.position = position;
      if (position > this.farthest) {
        return this.farthest = position;
      }
    };

    Parser.prototype.trace = function(action) {
      var i1, i2, indent, snippet, x, _i, _j, _ref, _ref1;
      indent = action.match(/^try_/);
      this.indent || (this.indent = 1);
      if (!indent) {
        this.indent--;
      }
      i1 = i2 = '';
      for (x = _i = 0, _ref = this.indent; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
        i1 += ' ';
      }
      for (x = _j = 1, _ref1 = 30 - action.length; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 1 <= _ref1 ? ++_j : --_j) {
        i2 += ' ';
      }
      if (indent) {
        this.indent++;
      }
      snippet = this.buffer.substr(this.position);
      if (snippet.length > 30) {
        snippet = snippet.substr(0, 30);
      }
      snippet = snippet.replace(/\n/g, '\\n');
      return console.warn("" + i1 + " " + action + i2 + ">" + snippet + "<");
    };

    Parser.prototype.throw_error = function(msg) {
      this.format_error(msg);
      if (!this.throw_on_error) {
        return 0;
      }
      throw this.error;
    };

    Parser.prototype.format_error = function(msg) {
      var column, context, line, lines, position;
      position = this.farthest;
      lines = (this.buffer.substr(0, position)).match(/\n/g);
      line = lines != null ? lines.length + 1 : 1;
      column = position - this.buffer.lastIndexOf("\n", position);
      context = this.buffer.substr(position, 50);
      context = context.replace(/\n/g, '\\n');
      return this.error = "Error parsing Pegex document:\n  msg: " + msg + "\n  line: " + line + "\n  column: " + column + "\n  context: " + context + "\n  position: " + position;
    };

    return Parser;

  })();

}).call(this);
