// Generated by CoffeeScript 1.3.3
(function() {
  var AST, Atoms, merge,
    __slice = [].slice;

  Atoms = require('../../Pegex/Grammar/Atoms').Atoms;

  merge = function() {
    var hash, k, object, rest, v, _i, _len;
    object = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = rest.length; _i < _len; _i++) {
      hash = rest[_i];
      for (k in hash) {
        v = hash[k];
        object[k] = v;
      }
    }
    return object;
  };

  exports.AST = AST = (function() {

    function AST() {
      this.toprule;
      this.extra_rules = {};
      this.prefixes = {
        '!': ['+asr', -1],
        '=': ['+asr', 1],
        '.': '-skip',
        '-': '-pass',
        '+': '-wrap'
      };
    }

    AST.prototype.got_grammar = function(rules) {
      var grammar, k, meta_section, rule, rule_section, v, _i, _len;
      meta_section = rules[0], rule_section = rules[1];
      grammar = merge({
        '+toprule': this.toprule
      }, this.extra_rules, meta_section);
      for (_i = 0, _len = rule_section.length; _i < _len; _i++) {
        rule = rule_section[_i];
        for (k in rule) {
          v = rule[k];
          grammar[k] = v;
        }
      }
      return grammar;
    };

    AST.prototype.got_meta_section = function(directives) {
      var key, meta, next, old, val, _i, _len;
      meta = {};
      for (_i = 0, _len = directives.length; _i < _len; _i++) {
        next = directives[_i];
        key = next[0], val = next[1];
        key = "+" + key;
        old = meta[key];
        if (old != null) {
          if (typeof old === 'object') {
            old.push(val);
          } else {
            meta[key] = [old, val];
          }
        } else {
          meta[key] = val;
        }
      }
      return meta;
    };

    AST.prototype.got_rule_definition = function(match) {
      var name, ret, value;
      name = match[0];
      if (name === 'TOP') {
        this.toprule = name;
      }
      this.toprule || (this.toprule = name);
      value = match[1];
      ret = {};
      ret[name] = value;
      return ret;
    };

    AST.prototype.got_bracketed_group = function(match) {
      var group, prefix, suffix;
      group = match[1];
      if (prefix = match[0]) {
        group[prefixes[prefix]] = 1;
      }
      if (suffix = match[-1]) {
        this.set_quantity(group(suffix));
      }
      return group;
    };

    AST.prototype.got_all_group = function(match) {
      var list;
      list = this.get_group(match);
      if (!list.length) {
        throw 42;
      }
      if (list.length === 1) {
        return list[0];
      }
      return {
        '.all': list
      };
    };

    AST.prototype.got_any_group = function(match) {
      var list;
      list = this.get_group(match);
      if (!list.length) {
        throw 42;
      }
      if (list.length === 1) {
        return list[0];
      }
      return {
        '.any': list
      };
    };

    AST.prototype.get_group = function(group) {
      var get;
      get = function(it) {
        var x, _i, _len;
        if (typeof it !== 'object') {
          return;
        }
        if (it instanceof Array) {
          for (_i = 0, _len = it.length; _i < _len; _i++) {
            x = it[_i];
            return get(x);
          }
        } else {
          return it;
        }
      };
      return [get(group)];
    };

    AST.prototype.got_rule_part = function(part) {
      var rule, sep_on, sep_rule;
      rule = part[0], sep_on = part[1], sep_rule = part[2];
      if (sep_rule) {
        if (sep_op === '%%') {
          sep_rule['+eok'] = true;
        }
        rule['.sep'] = sep_rule;
      }
      return rule;
    };

    AST.prototype.got_rule_reference = function(match) {
      var key, node, prefix, ref, ref1, ref2, regex, suffix, val, _ref, _ref1;
      prefix = match[0], ref1 = match[1], ref2 = match[2], suffix = match[3];
      ref = ref1 != null ? ref1 : ref2;
      node = {
        '.ref': ref
      };
      if (regex = Atoms.prototype.atoms()[ref]) {
        this.extra_rules[ref] = {
          '.rgx': regex
        };
      }
      if (suffix) {
        this.set_quantity(node, suffix);
      }
      if (prefix) {
        _ref = [prefixes[prefix], 1], key = _ref[0], val = _ref[1];
        if (typeof key === 'object') {
          _ref1 = key, key = _ref1[0], val = _ref1[1];
        }
        node[key] = val;
      }
      return node;
    };

    AST.prototype.got_regular_expression = function(match) {
      match = match.replace(/\s*#.*\n/g, '');
      match = match.replace(/\s+/g, '');
      match = match.replace(/\((\:|\=|\!)/g, '(?$1');
      return {
        '.rgx': match
      };
    };

    AST.prototype.got_whitespace_token = function(match) {
      var regex;
      regex = '<ws' + match.length + '>';
      return {
        '.rgx': regex
      };
    };

    AST.prototype.got_error_message = function(match) {
      return {
        '.err': match
      };
    };

    AST.prototype.set_quantity = function(object, quantifier) {
      if (quantifier === '*') {
        return object['+min'] = 0;
      } else if (quantifier === '+') {
        return object['+min'] = 1;
      } else if (quantifier === '?') {
        return object['+max'] = 1;
      } else if (quantifier.match(/^(\d+)\+$/)) {
        return object['+min'] = RegExp.$1;
      } else if (quantifier.match(/^(\d+)\-(\d+)$/)) {
        object['+min'] = RegExp.$1;
        return object['+max'] = RegExp.$2;
      } else if (quantifier.match(/^(\d+)$/)) {
        object['+min'] = RegExp.$1;
        return object['+max'] = RegExp.$1;
      } else {
        throw "Invalid quantifier: '" + quantifier + "'";
      }
    };

    return AST;

  })();

}).call(this);
