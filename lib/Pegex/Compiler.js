// Generated by CoffeeScript 1.3.3

/*
name:      Pegex::Compiler
abstract:  Pegex Compiler
author:    Ingy d√∂t Net <ingy@ingy.net>
license:   perl
copyright: 2011
*/


(function() {
  var Atoms, Compiler;

  Atoms = require('../Pegex/Grammar/Atoms');

  Compiler = (function() {

    function Compiler() {}

    Compiler.prototype.compile = function(input) {
      this.parse(input);
      this.combinate();
      return this;
    };

    Compiler.prototype.parse = function(input) {
      var parser;
      parser = new Parser({
        grammar: new Grammar,
        receiver: new AST
      });
      this.tree = parser.parse(input);
      return this;
    };

    Compiler.prototype.combinate = function(rule) {
      var k, v, _ref, _results;
      if (rule == null) {
        rule = this.tree['+toprule'];
      }
      if (!rule) {
        return this;
      }
      this._tree = {};
      _ref = this.tree;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        if (k.match(/^\+/)) {
          _results.push(this._tree.k = v);
        }
      }
      return _results;
    };

    Compiler.prototype.combinate_rule = function(rule) {
      var object;
      if (this._tree[rule] != null) {
        return;
      }
      object = this._tree[rule] = this.tree[rule];
      return this.combinate_object(object);
    };

    Compiler.prototype.combinate_object = function(object) {
      var elem, rule, _i, _j, _len, _len1, _ref, _ref1;
      if (object['.sep'] != null) {
        this.combinate_object(object['.sep']);
      }
      if (object['.rgx']) {
        this.combinate_re(object);
      } else if (object['.ref'] != null) {
        rule = object['.ref'];
        if (this.tree[rule] != null) {
          this.combinate_rule(rule);
        }
      } else if (object['.any'] != null) {
        _ref = object['.any'];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          elem = _ref[_i];
          this.combinate_object(elem);
        }
      } else if (object['.all'] != null) {
        _ref1 = object['.all'];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          elem = _ref1[_j];
          this.combinate_object(elem);
        }
      } else if (object['.err']) {
        1;

      } else {
        throw "Can't combinate: " + object;
      }
      return this;
    };

    Compiler.prototype.combinate_re = function(regexp) {
      var atoms, re, _results;
      atoms = Atoms.atoms;
      re = regexp['.rgx'];
      _results = [];
      while (true) {
        re = re.replace(/(?<!\\)(~+)/g, function(m, $1) {
          return '<ws' + $1.length + '>';
        });
        re = re.replace(/<(\w+)>/, function(m, $1) {
          if (this.tree[$1] != null) {
            return this.tree[$1]['.rgx'];
          } else if (atoms[$1] != null) {
            return atoms[$1];
          } else {
            throw "'" + $1 + "' not defined in the grammar";
          }
        });
        if (re === regexp['.rgx']) {
          break;
        }
        _results.push(regexp['.rgx'] = re);
      }
      return _results;
    };

    Compiler.prototype.to_yaml = function() {
      throw "Pegex.Compiler.to_yaml not yet defined";
    };

    Compiler.prototype.to_json = function() {
      return JSON.stringify(this.tree);
    };

    return Compiler;

  })();

}).call(this);
